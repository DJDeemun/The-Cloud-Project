// worker.js ‚Äî CloudPRX (single-file Cloudflare Worker, modules syntax)
// Discord-inspired UI (dark first), curvy tabs, pill omnibox (white icons), thin progress bar
// Per-tab history, Brave search, Bookmarks (add/remove via star, persistent),
// Bookmarks section on NTP, Kebab menu ‚Üí Bookmarks/Help/About/Preferences/Panic. F1 opens Help.
// Added: WebSocket proxy (/ws/... + client patch), inline meta CSP removal, session restore prefs,
// Panic opens Chrome new tab if allowed (fallback about:blank), Copy-URL button.
// Minimal error pages; "Home" on errors triggers real viewer Home (no nesting)

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      const path = normalizePath(url.pathname);

      if (request.method !== "GET" && request.method !== "POST") {
        return text("Method Not Allowed", 405);
      }

      if (path === "/" || path === "/index.html") {
        return withHeaders(viewerHTML(), {
          "content-type": "text/html; charset=UTF-8",
          "x-content-type-options": "nosniff",
          "referrer-policy": "no-referrer",
        });
      }

      if (path === "/robots.txt") {
        return withHeaders("User-agent: *\nDisallow:", {
          "content-type": "text/plain; charset=UTF-8",
        });
      }

      if (path === "/p/sw.js") {
        return withHeaders(swJS(), {
          "content-type": "application/javascript; charset=UTF-8",
          "cache-control": "no-store",
        });
      }

      if (path.startsWith("/ws/")) {
        return handleWebSocket(request);
      }

      if (path.startsWith("/p/")) {
        return handleProxy(request);
      }

      // Pretty 404 for everything else
      return text("Not Found", 404);
    } catch (err) {
      return text(`Worker crashed: ${err && err.message ? err.message : String(err)}`, 500);
    }
  },
};

// ---------- Core Proxy ----------

const HOP_BY_HOP = new Set([
  "connection","keep-alive","proxy-authenticate","proxy-authorization",
  "te","trailer","transfer-encoding","upgrade",
]);

const STRIP_HEADERS = new Set([
  "x-frame-options","content-security-policy","content-security-policy-report-only",
  "cross-origin-opener-policy","cross-origin-embedder-policy","cross-origin-resource-policy",
  "report-to","nel",
]);

const COOKIE_PREFIX = "__t__";

function normalizePath(p){ return p.replace(/\/+/g, "/"); }

function decodeProxyTarget(reqUrl){
  // /p/<scheme>/<host[:port]>/<path...>
  const u = new URL(reqUrl);
  const seg = normalizePath(u.pathname).split("/").filter(Boolean);
  if (seg.length < 3) return null;
  const scheme = seg[1];
  const hostPort = seg[2];
  const rest = seg.slice(3).join("/");
  if (!/^https?$/.test(scheme)) return null;
  const upstream = new URL(`${scheme}://${hostPort}/${rest}`);
  upstream.search = u.search;
  return upstream;
}

function toProxyPath(absUrl){
  const scheme = absUrl.protocol.replace(":", "");
  const hostPort = absUrl.host;
  const path = absUrl.pathname.replace(/^\/+/, "");
  const q = absUrl.search || "";
  return `/p/${scheme}/${hostPort}/${path}${q}`;
}

function proxifyMaybe(baseUrl, raw){
  if (!raw) return raw;
  try {
    const base = baseUrl instanceof URL ? baseUrl : new URL(baseUrl);
    const abs = new URL(raw, base);
    return toProxyPath(abs);
  } catch { return raw; }
}

function cleanRequestHeaders(headers, upstreamUrl){
  const out = new Headers();
  headers.forEach((v, k) => {
    const key = k.toLowerCase();
    if (HOP_BY_HOP.has(key)) return;
    if (key === "host") return;
    if (key === "cf-connecting-ip" || key === "x-forwarded-for" || key === "x-real-ip") return;
    if (key === "origin") { try { out.set("origin", `${upstreamUrl.protocol}//${upstreamUrl.host}`); } catch {} return; }
    if (key === "referer"){ out.set("referer", `${upstreamUrl.protocol}//${upstreamUrl.host}/`); return; }
    if (key === "content-length") return;
    out.set(key, v);
  });
  out.set("host", upstreamUrl.host);
  out.set("accept-encoding", "");
  return out;
}

function pickCookiesForUpstream(request, upstreamUrl){
  const cookieHeader = request.headers.get("cookie") || "";
  if (!cookieHeader) return "";
  const parsed = Object.fromEntries(
    cookieHeader.split(/;\s*/g).filter(Boolean).map(kv => {
      const i = kv.indexOf("="); return [kv.slice(0,i).trim(), kv.slice(i+1)];
    })
  );
  const hostKey = cookieHostKey(upstreamUrl.host);
  const pairs = [];
  for (const [name, val] of Object.entries(parsed)) {
    if (name.startsWith(COOKIE_PREFIX + hostKey + "__")) {
      const orig = name.slice((COOKIE_PREFIX + hostKey + "__").length);
      pairs.push(`${orig}=${val}`);
    }
  }
  return pairs.join("; ");
}

function cookieHostKey(host){ return host.replace(/\./g, "_"); }

function rewriteSetCookies(headers, upstreamUrl, https){
  const out = new Headers(headers);
  out.delete("set-cookie");
  const setCookies = [];
  headers.forEach((v,k)=>{ if (k.toLowerCase()==="set-cookie") setCookies.push(v); });
  const hostKey = cookieHostKey(upstreamUrl.host);
  for (const sc of setCookies){
    const m = /^([^=;]+)=([^;]*)(.*)$/i.exec(sc);
    if (!m) continue;
    const name = m[1].trim(); const val = m[2]; const attrs = m[3] || "";
    const namespaced = `${COOKIE_PREFIX}${hostKey}__${name}`;
    const secure = /\bsecure\b/i.test(attrs) || https ? "; Secure" : "";
    const httpOnly = "; HttpOnly";
    const sameSite = /\bsamesite=/i.test(attrs) ? "" : "; SameSite=Lax";
    const path = `; Path=/p/${upstreamUrl.protocol.replace(":","")}/${upstreamUrl.host}/`;
    out.append("Set-Cookie", `${namespaced}=${val}${path}${httpOnly}${secure}${sameSite}`);
  }
  return out;
}

function stripProblemHeaders(headers){
  const out = new Headers();
  headers.forEach((v,k)=>{
    const key = k.toLowerCase();
    if (HOP_BY_HOP.has(key)) return;
    if (STRIP_HEADERS.has(key)) return;
    if (key === "content-length") return;
    out.set(k, v);
  });
  return out;
}

async function handleProxy(request){
  const upstreamUrl = decodeProxyTarget(request.url);
  if (!upstreamUrl) return text("Bad proxy path", 400);

  const method = request.method.toUpperCase();
  const body = method === "GET" || method === "HEAD" ? undefined : request.body;

  const headers = cleanRequestHeaders(request.headers, upstreamUrl);
  const upstreamCookies = pickCookiesForUpstream(request, upstreamUrl);
  if (upstreamCookies) headers.set("cookie", upstreamCookies); else headers.delete("cookie");

  const upstreamReq = new Request(upstreamUrl.toString(), { method, headers, body, redirect: "manual" });

  let upstreamResp;
  try { upstreamResp = await fetch(upstreamReq); }
  catch (e) {
    return text(
      `Upstream fetch error while contacting ${upstreamUrl.toString()}: ${e && e.message ? e.message : String(e)}`,
      502
    );
  }

  let headersOut = stripProblemHeaders(upstreamResp.headers);
  headersOut = rewriteSetCookies(headersOut, upstreamUrl, true);
  headersOut.set("referrer-policy","no-referrer");
  headersOut.set("x-content-type-options","nosniff");

  // Redirects
  if ([301,302,303,307,308].includes(upstreamResp.status)){
    const loc = upstreamResp.headers.get("location");
    if (loc){ try { headersOut.set("location", toProxyPath(new URL(loc, upstreamUrl))); } catch {} }
    return new Response(null, { status: upstreamResp.status, headers: headersOut });
  }

  // Replace Cloudflare/plain 4xx/5xx pages with our minimal page
  const ctRaw = upstreamResp.headers.get("content-type") || "";
  const ct = ctRaw.toLowerCase();
  if (upstreamResp.status >= 400) {
    const isPlain = ct.includes("text/plain");
    const server = (upstreamResp.headers.get("server") || "").toLowerCase();
    const cfRay = upstreamResp.headers.get("cf-ray");
    const looksCloudflare = server.includes("cloudflare") || !!cfRay;
    if (isPlain || looksCloudflare) {
      headersOut.set("cache-control","no-store");
      return new Response(
        errorHTML({
          code: upstreamResp.status,
          label: statusText(upstreamResp.status),
          message: looksCloudflare
            ? "Cloudflare returned an error while contacting this site."
            : "The site responded with an error.",
          detail: escapeHtmlAttr(upstreamUrl.toString())
        }),
        { status: upstreamResp.status, headers: mergeHeaders(headersOut, { "content-type":"text/html; charset=UTF-8" }) }
      );
    }
  }

  const status = upstreamResp.status;

  if (ct.includes("text/html")){
    const baseRes = new Response(upstreamResp.body, { status, headers: headersOut });
    const baseHref = `/p/${upstreamUrl.protocol.replace(":","")}/${upstreamUrl.host}/`;
    const injector = new HTMLRewriter()
      .on("head", { element(el){
        el.append(`<base href="${escapeHtmlAttr(baseHref)}">`, { html: true });
        el.append(`<script>${clientPatchJS()}</script>`, { html: true });
      }})
      .on('meta[http-equiv="content-security-policy"]', { element(el){ el.remove(); }})
      .on("a[href]", attrRewriter("href", upstreamUrl))
      .on("area[href]", attrRewriter("href", upstreamUrl))
      .on("form[action]", attrRewriter("action", upstreamUrl))
      .on("img[src]", attrRewriter("src", upstreamUrl))
      .on("script[src]", attrRewriter("src", upstreamUrl))
      .on("link[href]", attrRewriter("href", upstreamUrl))
      .on("iframe[src]", attrRewriter("src", upstreamUrl))
      .on("audio[src]", attrRewriter("src", upstreamUrl))
      .on("video[src]", attrRewriter("src", upstreamUrl))
      .on("source[src]", attrRewriter("src", upstreamUrl))
      .on("video[poster]", attrRewriter("poster", upstreamUrl))
      .on("img[srcset]", srcsetRewriter("srcset", upstreamUrl))
      .on("source[srcset]", srcsetRewriter("srcset", upstreamUrl))
      .on('meta[http-equiv="refresh"][content]', metaRefreshRewriter("content", upstreamUrl));
    headersOut.set("cache-control","no-store");
    return injector.transform(baseRes);
  }

  if (ct.includes("text/css")){
    headersOut.set("cache-control","private, max-age=300");
    const cssText = await upstreamResp.text();
    const rewritten = rewriteCssUrls(cssText, upstreamUrl);
    return new Response(rewritten, {
      status,
      headers: mergeHeaders(headersOut, { "content-type": "text/css; charset=UTF-8" }),
    });
  }

  if (!ct.includes("javascript")) {
    if (!headersOut.has("cache-control")) headersOut.set("cache-control","public, max-age=600");
  } else {
    headersOut.set("cache-control","private, max-age=300");
  }
  return new Response(upstreamResp.body, { status, headers: headersOut });
}

// ---------- WebSocket proxy ----------

function decodeWebSocketTarget(reqUrl){
  // /ws/<ws|wss>/<host[:port]>/<path...>
  const u = new URL(reqUrl);
  const seg = normalizePath(u.pathname).split("/").filter(Boolean);
  if (seg.length < 3 || seg[0] !== "ws") return null;
  const scheme = seg[1];
  if (!/^wss?$/.test(scheme)) return null;
  const hostPort = seg[2];
  const rest = seg.slice(3).join("/");
  const upstream = new URL(`${scheme}://${hostPort}/${rest}`);
  upstream.search = u.search;
  return upstream;
}

async function handleWebSocket(request){
  const upgrade = (request.headers.get("upgrade") || "").toLowerCase();
  if (upgrade !== "websocket") return text("Expected WebSocket", 400);
  const upstreamUrl = decodeWebSocketTarget(request.url);
  if (!upstreamUrl) return text("Bad ws path", 400);

  const headers = cleanRequestHeaders(request.headers, upstreamUrl);
  const upstreamCookies = pickCookiesForUpstream(request, upstreamUrl);
  if (upstreamCookies) headers.set("cookie", upstreamCookies); else headers.delete("cookie");
  headers.set("upgrade","websocket");

  const upstreamResp = await fetch(upstreamUrl.toString(), { method: "GET", headers });
  if (!upstreamResp.webSocket) return text("Upstream refused WebSocket", 502);

  const upstream = upstreamResp.webSocket;
  upstream.accept();

  const pair = new WebSocketPair();
  const client = pair[0];
  const server = pair[1];
  server.accept();

  server.addEventListener("message", ev => upstream.send(ev.data));
  upstream.addEventListener("message", ev => server.send(ev.data));

  const closeBoth = (code, reason) => {
    try { server.close(code, reason); } catch {}
    try { upstream.close(code, reason); } catch {}
  };
  server.addEventListener("close", ev => closeBoth(ev.code, ev.reason));
  upstream.addEventListener("close", ev => closeBoth(ev.code, ev.reason));
  server.addEventListener("error", () => closeBoth(1011, "client error"));
  upstream.addEventListener("error", () => closeBoth(1011, "upstream error"));

  return new Response(null, { status: 101, webSocket: client });
}

// ---------- HTML Rewriter helpers ----------

function attrRewriter(attrName, baseUrl){
  return { element(el){
    const val = el.getAttribute(attrName); if (!val) return;
    const prox = proxifyMaybe(baseUrl, val);
    if (prox) el.setAttribute(attrName, prox);
  }};
}

function srcsetRewriter(attrName, baseUrl){
  return { element(el){
    const val = el.getAttribute(attrName); if (!val) return;
    const parts = val.split(",").map(p=>p.trim()).filter(Boolean).map(entry=>{
      const m = /^(\S+)(\s+.+)?$/.exec(entry);
      if (!m) return entry;
      const url = m[1]; const tail = m[2] || "";
      const prox = proxifyMaybe(baseUrl, url);
      return (prox || url) + tail;
    });
    el.setAttribute(attrName, parts.join(", "));
  }};
}

function metaRefreshRewriter(attrName, baseUrl){
  return { element(el){
    const val = el.getAttribute(attrName); if (!val) return;
    const m = /^(\s*\d+\s*;\s*url\s*=\s*)(.+)\s*$/i.exec(val);
    if (!m) return;
    const lead = m[1]; const url = m[2];
    const prox = proxifyMaybe(baseUrl, url);
    if (prox) el.setAttribute(attrName, `${lead}${prox}`);
  }};
}

// ---------- CSS url(...) rewriting ----------

function rewriteCssUrls(cssText, baseUrl){
  return cssText.replace(/url\(\s*(['"]?)([^'")]+)\1\s*\)/g, (m, q, raw) => {
    const trimmed = raw.trim();
    if (/^(data:|about:)/i.test(trimmed)) return m;
    try {
      const out = proxifyMaybe(baseUrl, trimmed);
      if (!out) return m;
      return `url(${q || ""}${out}${q || ""})`;
    } catch { return m; }
  });
}

// ---------- Client helpers injected into proxied HTML ----------

function clientPatchJS(){
  return `
(function(){
  "use strict";
  function currentTarget(){
    var m = location.pathname.match(/^\\/p\\/(https?)\\/([^/]+)\\//i);
    return m ? { scheme: m[1], hostport: m[2] } : null;
  }
  function toProxy(u){
    try{
      var tgt = currentTarget(); if(!tgt) return u;
      var base = new URL(tgt.scheme + "://" + tgt.hostport + "/");
      var abs = new URL(u, document.baseURI || base.toString());
      if (abs.origin === location.origin && abs.pathname.startsWith("/p/")) return abs.toString();
      return "/p/" + abs.protocol.replace(":","") + "/" + abs.host + abs.pathname + abs.search;
    }catch(_){ return u; }
  }
  // Patch fetch + XHR
  var _fetch = window.fetch;
  window.fetch = function(input, init){
    try{
      if (typeof input === "string") { input = toProxy(input); }
      else if (input && input.url) {
        var nu = toProxy(input.url); if (nu !== input.url) input = new Request(nu, input);
      }
    }catch(_){}
    return _fetch(input, init);
  };
  var _open = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function(method, url){
    try { url = toProxy(url); } catch(_){}
    return _open.apply(this, [method, url].concat([].slice.call(arguments, 2)));
  };

  // WebSocket reroute through Worker
  (function(){
    var _WS = window.WebSocket;
    function toProxyWS(u){
      try{
        var m = location.pathname.match(/^\\/p\\/(https?)\\/([^/]+)\\//i);
        var scheme = "wss";
        var hostport = (m ? m[2] : location.host);
        var base = new URL((m?m[1]:"https") + "://" + hostport + "/");
        var abs = new URL(u, document.baseURI || base.toString());
        var proto = abs.protocol.replace(":","").replace(/^http$/,"ws").replace(/^https$/,"wss");
        return "/ws/" + proto + "/" + abs.host + abs.pathname + abs.search;
      }catch(_){ return u; }
    }
    window.WebSocket = function(url, protocols){
      try { url = toProxyWS(url); } catch(_) {}
      return new _WS(url, protocols);
    };
    window.WebSocket.prototype = _WS.prototype;
  })();

  function ping(){
    try { parent && parent.postMessage({__cb:1, type:"loc", href: location.href, title: document.title || ""}, "*"); } catch(_){}
  }
  var _ps = history.pushState, _rs = history.replaceState;
  history.pushState = function(){ var r=_ps.apply(this, arguments); ping(); return r; };
  history.replaceState = function(){ var r=_rs.apply(this, arguments); ping(); return r; };
  window.addEventListener("popstate", ping);
  document.addEventListener("DOMContentLoaded", ping);
  new MutationObserver(ping).observe(document.querySelector("title")||document.documentElement,{subtree:true,childList:true,characterData:true});

  document.addEventListener("click", function(ev){
    var a = ev.target && ev.target.closest ? ev.target.closest("a[href]") : null;
    if (!a) return;
    if (a.target && a.target !== "_self") return;
    var href = a.getAttribute("href"); if (!href) return;
    var prox = toProxy(href);
    if (prox && prox !== href) { ev.preventDefault(); location.assign(prox); }
  }, true);
})();`.trim();
}

// ---------- Viewer UI (Discord-like; white icons; bookmarks; prefs; panic; copy-url) ----------

function viewerHTML(){
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CloudPRX</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="theme-color" content="#313338" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#f2f3f5" media="(prefers-color-scheme: light)">
  <link rel="icon" sizes="any" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='196' height='196' viewBox='0 0 128 128'%3E%3Cg%3E%3Crect rx='28' width='128' height='128' fill='%235865F2'/%3E%3Ctext x='64' y='70' font-size='64' text-anchor='middle' fill='white' font-family='ui-sans-serif,system-ui'%3E‚òÅ%3C/text%3E%3C/g%3E%3C/svg%3E">
  <style>
    :root{
      /* Light (still dark-leaning for Discord vibe) */
      --bg:#f2f3f5; --fg:#2b2d31; --muted:#6b6f78;
      --tabbar:#e6e7eb; --tab-active:#ffffff; --tab-inactive:#e9eaee; --tab-border:#d7d8de;
      --omnibox:#ffffff; --omnibox-border:#d9dbe0; --omnibox-focus:#5865F2;
      --accent:#5865F2; --progress:#5865F2;
      --radius: 16px; --radius-sm: 10px; --radius-lg: 22px;
      --shadow-1: 0 1px 2px rgba(0,0,0,.08), 0 3px 8px rgba(0,0,0,.06);
      --shadow-2: 0 10px 24px rgba(0,0,0,.12);
      --edgefade: linear-gradient(90deg, rgba(0,0,0,0.08), transparent 30%, transparent 70%, rgba(0,0,0,0.08));
    }
    @media (prefers-color-scheme: dark){
      :root{
        /* Discord palette */
        --bg:#1e1f22; --fg:#e3e5e8; --muted:#b5bac1;
        --tabbar:#2b2d31; --tab-active:#313338; --tab-inactive:#2b2d31; --tab-border:#3f4147;
        --omnibox:#313338; --omnibox-border:#3f4147; --omnibox-focus:#5865F2;
        --accent:#5865F2; --progress:#5865F2;
        --shadow-1: 0 2px 8px rgba(0,0,0,.45);
        --shadow-2: 0 14px 40px rgba(0,0,0,.55);
      }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--fg); background:var(--bg);
      display:grid; grid-template-rows:auto 1fr;
      font: 13px/1.4 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    button{ font:inherit }
    :focus-visible{ outline:2px solid var(--omnibox-focus); outline-offset:2px; border-radius:12px }

    header{ position:sticky; top:0; z-index:10; background:var(--tabbar); box-shadow:var(--shadow-1); }
    .tabsbar{ padding:8px 10px 0; }
    .tabs{
      position:relative; display:flex; gap:8px; overflow:auto; scrollbar-width:thin; padding:0 6px 8px;
      -webkit-mask-image: radial-gradient(8px at left, transparent 6px, black 6.5px), radial-gradient(8px at right, transparent 6px, black 6.5px), linear-gradient(to right, black 30%, black 70%);
      mask-composite: add;
    }
    .tabs::-webkit-scrollbar{ height:8px } .tabs::-webkit-scrollbar-thumb{ background:rgba(255,255,255,.15); border-radius:10px }
    .tabs::after{ content:""; pointer-events:none; position:absolute; inset:0; background:var(--edgefade); opacity:.14; }
    .tab{
      position:relative; display:flex; align-items:center; gap:8px;
      height:34px; padding:0 12px; min-width:120px; max-width:260px;
      color:var(--fg); background:var(--tab-inactive);
      border:1px solid var(--tab-border); border-bottom-color: transparent;
      border-radius:12px 12px 0 0; white-space:nowrap; user-select:none; cursor:pointer;
      transition: transform .08s ease, background .18s ease, box-shadow .18s ease;
    }
    .tab:hover{ transform: translateY(-0.5px) }
    .tab.active{ background:var(--tab-active); z-index:1; box-shadow: var(--shadow-1); }
    .tab img.fav, .tab .fav{ width:16px;height:16px; border-radius:4px; flex:0 0 auto; display:block; }
    .spinner{ width:16px;height:16px; border:2px solid rgba(255,255,255,.35); border-top-color:#fff; border-radius:50%; animation:spin .9s linear infinite; filter: drop-shadow(0 0 1px rgba(0,0,0,.35)); }
    @keyframes spin{ to{ transform:rotate(360deg) } }
    .title{ overflow:hidden; text-overflow:ellipsis; flex:1 1 auto; min-width:42px; font-size:12.5px }
    .close{ height:22px; width:22px; border-radius:8px; flex:0 0 auto; display:grid; place-items:center; border:1px solid var(--tab-border); background:transparent; font-weight:900; line-height:1; opacity:.0; transition:opacity .12s ease, transform .06s ease; }
    .tab:hover .close, .tab.active .close{ opacity:.9 }
    .close:active{ transform: translateY(1px) }
    .tab.add{ min-width:unset; width:auto; font-weight:900; padding:0 10px; }
    .hairline{ height:1px; background:var(--tab-border); opacity:.8; }

    .bar{ display:flex; align-items:center; gap:8px; padding:8px 12px 12px; }
    .toolbtn{ height:32px;width:32px;border-radius:8px;border:1px solid var(--omnibox-border); background:var(--omnibox); display:grid; place-items:center; cursor:pointer; transition:transform .06s ease, background .15s ease; }
    .toolbtn:active{ transform: translateY(1px) }
    .toolbtn:disabled{ opacity:.5; cursor:not-allowed }

    /* toolbar + omnibox icons white (Discord vibe) */
    .toolbtn svg, .omnibtn svg { color:#fff; filter: drop-shadow(0 0 1px rgba(0,0,0,.35)); }
    .omnibtn#more { color:#fff; text-shadow: 0 0 1px rgba(0,0,0,.35); }

    .barform{ display:flex; align-items:center; gap:8px; flex:1; min-width:0; background:var(--omnibox); border:1px solid var(--omnibox-border); border-radius:999px; padding:6px 8px 6px 8px; box-shadow: var(--shadow-1); transition: box-shadow .15s ease; }
    .barform:focus-within{ box-shadow: var(--shadow-2) }
    .omnibtn{ height:28px;width:28px;border:0;background:transparent; border-radius:999px; display:grid; place-items:center; cursor:pointer; transition: background .12s ease; }
    .omnibtn:hover{ background:rgba(0,0,0,.06) }
    @media (prefers-color-scheme: dark){ .omnibtn:hover{ background:rgba(255,255,255,.08) } }
    .barform input[type=text]{ flex:1; min-width:0; padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,.10); background:transparent; color:var(--fg); outline:none; caret-color:var(--accent); font-size:14.5px; box-shadow:inset 0 1px 0 rgba(255,255,255,.12); transition: border-color .25s ease, background .25s ease, box-shadow .25s ease; }
    .barform input::placeholder{ color:var(--muted); }
    .barform input:focus{ border-color:var(--omnibox-focus); box-shadow:inset 0 1px 0 rgba(255,255,255,.18), 0 0 0 2px color-mix(in oklab, var(--omnibox-focus) 35%, transparent); }
    .barform button.go{ height:28px; padding:0 12px; border-radius:999px; border:0; background:var(--accent); color:white; font-weight:700; letter-spacing:.2px; cursor:pointer; transition: transform .06s ease, filter .12s ease; }
    .barform button.go:active{ transform: translateY(1px) }
    .brand{ font-size:12px; color:var(--muted); user-select:none; padding-left:8px }

    .omnibtn.star svg path{ stroke:#fff; fill:none; stroke-width:2; }
    .omnibtn.star.active svg path{ fill:#fff; }

    .menu{ position:absolute; display:none; z-index:30; min-width:220px; border:1px solid var(--omnibox-border); background:var(--omnibox); color:var(--fg); border-radius:12px; box-shadow: var(--shadow-2); padding:6px; }
    .menu.show{ display:block; animation: pop .12s ease-out }
    @keyframes pop{ from{ transform: translateY(-6px) scale(.98); opacity:0 } to{ transform:none; opacity:1 } }
    .menu .item{ display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:8px; cursor:pointer; }
    .menu .item:hover{ background:rgba(0,0,0,.06) }
    @media (prefers-color-scheme: dark){ .menu .item:hover{ background:rgba(255,255,255,.08) } }
    .menu .sep{ height:1px; background:var(--omnibox-border); margin:6px 4px }

    .progress-rail{ position:relative; height:2px; background:transparent; }
    .progress{ position:absolute; left:0; top:0; height:100%; width:0%; background:var(--progress); box-shadow: 0 0 10px var(--progress); transition:width .2s ease }

    #content{ position:relative; min-height:0; overflow:hidden; }
    .viewerWrap{ position:absolute; inset:0; border-top-left-radius:16px; border-top-right-radius:16px; overflow:hidden; }
    #view{ position:absolute; inset:0; width:100%; height:100%; border:0; display:none; background:var(--bg) }
    #view.show{ display:block }

    #hero{position:absolute;inset:0;display:grid;place-items:start center;padding-top:10vh; animation: fadein .2s ease }
    @keyframes fadein{ from{ opacity:0; transform: translateY(4px) } to{ opacity:1; transform:none } }
    .ntp{ display:grid; gap:18px; width:min(980px, calc(100vw - 32px)); justify-items:center; }
    .logo{ font: 800 40px/1.15 ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; letter-spacing:.2px; }
    .logo .mark{ padding:2px 10px; border-radius:999px; background: color-mix(in oklab, var(--accent) 20%, transparent); }
    .tag{color:var(--muted); font-size:13px}

    .ntpSearch{ display:flex; gap:8px; align-items:center; padding:12px 14px; border-radius:999px; border:1px solid var(--omnibox-border); background:var(--omnibox); width:min(780px, 100%); box-shadow: var(--shadow-1); }
    .ntpSearch input{ flex:1; min-width:0; border:0; outline:0; background:transparent; color:var(--fg); font-size:16px; }
    .ntpSearch button{ height:32px; padding:0 14px; border-radius:16px; border:0; background:var(--accent); color:#fff; font-weight:700; }

    .sitesCard{ text-align:left; padding:12px 12px; border-radius:16px; border:1px solid var(--omnibox-border); background:var(--omnibox); width:min(780px, 100%); box-shadow: var(--shadow-1); }
    .sitesCard h3{ margin:0 0 8px; font-size:13px; color:var(--muted); letter-spacing:.3px; font-weight:700 }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap:10px; list-style:none; margin:0; padding:0 }
    .grid li{ position:relative }
    .grid a{ display:flex; align-items:center; gap:10px; text-decoration:none; color:var(--fg); padding:8px 10px; border-radius:12px; border:1px solid var(--omnibox-border); background:var(--omnibox); transition: transform .06s ease, background .12s ease; }
    .grid a:hover{ background:rgba(0,0,0,.04) }
    @media (prefers-color-scheme: dark){ .grid a:hover{ background:rgba(255,255,255,.06) } }
    .tick{ width:18px; height:18px; display:grid; place-items:center; border-radius:6px; border:1px solid var(--omnibox-border); }

    #bmList .rm{ position:absolute; right:6px; top:6px; height:20px; width:20px; border:1px solid var(--omnibox-border); background:transparent; color:var(--muted); border-radius:6px; line-height:18px; text-align:center; cursor:pointer; }
    #bmList .rm:hover{ color:#d93025; border-color:#d93025 }

    .modal{ position:fixed; inset:0; display:none; z-index:25; }
    .modal.show{ display:block; }
    .modal .backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.45) }
    .modal .card{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:min(720px, calc(100vw - 32px)); max-height:80vh; overflow:auto; border-radius:16px; border:1px solid var(--omnibox-border); background:var(--omnibox); color:var(--fg); box-shadow: var(--shadow-2); }
    .modal .head{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:12px; border-bottom:1px solid var(--omnibox-border); }
    .modal .head h2{ margin:0; font-size:16px; letter-spacing:.2px }
    .modal .closeX{ height:28px; width:28px; border-radius:8px; border:1px solid var(--omnibox-border); background:transparent; color:var(--fg); font-weight:900; cursor:pointer; }
    .modal .body{ padding:12px; font-size:14px; line-height:1.55; }

    @media (prefers-reduced-motion: reduce){ *{ transition:none !important; animation:none !important } }
  </style>
</head>
<body>
  <header>
    <div class="tabsbar">
      <div class="tabs" id="tabs" role="tablist" aria-label="Tabs"></div>
    </div>
    <div class="hairline" aria-hidden="true"></div>
    <div class="bar">
      <button id="home" class="toolbtn" title="Home (Alt+Home)" aria-label="Home">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M4 12l8-7 8 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M8 21V11h8v10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button id="back" class="toolbtn" title="Back (Alt+Left)" aria-label="Back">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M14.5 6.5L8 12l6.5 5.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button id="fwd" class="toolbtn" title="Forward (Alt+Right)" aria-label="Forward">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true" style="transform:scaleX(-1)">
          <path d="M14.5 6.5L8 12l6.5 5.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button id="refresh" class="toolbtn" title="Reload (Ctrl+R)" aria-label="Reload">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M21 12a9 9 0 10-3.3 6.9M21 12v-7m0 7h-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>

      <form id="go" class="barform" autocomplete="off" novalidate>
        <button type="button" class="omnibtn" id="info" title="Connection">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M7 10V7a5 5 0 0110 0v3M6 10h12v9H6z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <input id="u" type="text" inputmode="url" autocapitalize="off" placeholder="Type in a URL" spellcheck="false" />
        <button type="button" class="omnibtn" id="copyUrl" title="Copy URL">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M8 17h8a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-6l-4 4v6a2 2 0 0 0 2 2z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
          </svg>
        </button>
        <button type="button" class="omnibtn star" id="bookmark" title="Bookmark this page">
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 17.3l-5.2 3.1 1.4-5.9L3 9.6l6-.5L12 3l3 6.1 6 .5-5.2 4.9 1.4 5.9z"/>
          </svg>
        </button>
        <button type="button" class="omnibtn" id="more" title="Customize and control CloudPRX">‚ãÆ</button>
        <button class="go" type="submit" title="Go">Go</button>
      </form>

      <div class="brand">CloudPRX</div>
      <div id="menu" class="menu" role="menu" aria-hidden="true">
        <div class="item" data-act="new"><span>‚ûï</span> New tab</div>
        <div class="item" data-act="reopen"><span>‚§¥Ô∏è</span> Reopen closed tab</div>
        <div class="item" data-act="bm"><span>‚≠ê</span> Bookmarks</div>
        <div class="sep"></div>
        <div class="item" data-act="prefs"><span>‚öôÔ∏è</span> Preferences</div>
        <div class="item" data-act="panic"><span>üö®</span> Panic</div>
        <div class="sep"></div>
        <div class="item" data-act="help"><span>‚ùì</span> Help</div>
        <div class="item" data-act="about"><span>‚ÑπÔ∏è</span> About CloudPRX</div>
      </div>
    </div>
    <div class="progress-rail" aria-hidden="true"><div id="progress" class="progress"></div></div>
  </header>

  <div id="content">
    <div class="viewerWrap">
      <main id="hero" aria-label="CloudPRX New Tab">
        <div class="ntp">
          <div class="logo"><span class="mark">CloudPRX</span></div>
          <div class="tag">A sleek, Discord-inspired proxy. Search with Brave or type a URL.</div>

          <form id="heroSearch" class="ntpSearch" autocomplete="off">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2"/><path d="M20 20l-3.5-3.5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <input id="q" type="text" placeholder="Search Brave" />
            <button type="submit">Search</button>
          </form>

          <div class="sitesCard">
            <h3>Quick links</h3>
            <ul class="grid" id="workList">
              <li><a href="#" data-go="https://www.newgrounds.com"><span class="tick">‚úì</span> newgrounds.com</a></li>
              <li><a href="#" data-go="https://flappybird.io"><span class="tick">‚úì</span> flappybird.io</a></li>
              <li><a href="#" data-go="https://www.crazygames.com"><span class="tick">‚úì</span> crazygames.com</a></li>
              <li><a href="#" data-go="https://gamejolt.com"><span class="tick">‚úì</span> gamejolt.com</a></li>
              <li><a href="#" data-go="https://itch.io"><span class="tick">‚úì</span> itch.io</a></li>
            </ul>
          </div>

          <div class="sitesCard" id="bmCard" hidden>
            <h3>Your bookmarks</h3>
            <ul class="grid" id="bmList"></ul>
          </div>
        </div>
      </main>

      <iframe id="view" src="about:blank" allow="clipboard-read; clipboard-write; geolocation; microphone; camera;"></iframe>
    </div>
  </div>

  <div id="helpModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="backdrop"></div>
    <div class="card">
      <div class="head">
        <h2 id="helpTitle">CloudPRX ‚Äî Help & Tips</h2>
        <button class="closeX" aria-label="Close">√ó</button>
      </div>
      <div class="body">
        <p><strong>Go to a site:</strong> Type a domain like <code>example.com</code> ‚Äî <code>https://</code> will be added for you.</p>
        <p><strong>Search:</strong> Use the omnibox or the big search (Brave Search).</p>
        <ul>
          <li><span class="kbd">Ctrl</span>+<span class="kbd">L</span> focus the address bar</li>
          <li><span class="kbd">Alt</span>+<span class="kbd">‚Üê</span> / <span class="kbd">Alt</span>+<span class="kbd">‚Üí</span> back / forward</li>
          <li><span class="kbd">Ctrl</span>+<span class="kbd">R</span> reload current tab</li>
          <li>Home button or <span class="kbd">Alt</span>+<span class="kbd">Home</span> returns to the new tab page</li>
          <li><strong>Tabs:</strong> <span class="kbd">Ctrl</span>+<span class="kbd">T</span> new, <span class="kbd">Ctrl</span>+<span class="kbd">W</span> close, <span class="kbd">Ctrl</span>+<span class="kbd">Shift</span>+<span class="kbd">T</span> reopen. Drag to reorder. Middle-click to close. <span class="kbd">Ctrl</span>+<span class="kbd">1</span>‚Ä¶<span class="kbd">9</span> to jump.</li>
        </ul>
        <p><strong>Bookmarks:</strong> Click the ‚≠ê in the omnibox to add/remove the current page. Open Bookmarks from the menu or on the New Tab Page.</p>
      </div>
    </div>
  </div>

  <script>
    const $u = document.getElementById('u');
    const $v = document.getElementById('view');
    const $hero = document.getElementById('hero');
    const $home = document.getElementById('home');
    const $back = document.getElementById('back');
    const $fwd = document.getElementById('fwd');
    const $refresh = document.getElementById('refresh');
    const $prog = document.getElementById('progress');
    const $tabs = document.getElementById('tabs');
    const $helpModal = document.getElementById('helpModal');
    const $heroSearch = document.getElementById('heroSearch');
    const $q = document.getElementById('q');
    const $workList = document.getElementById('workList');
    const $lock = document.getElementById('info');
    const $more = document.getElementById('more');
    const $menu = document.getElementById('menu');
    const $bookmark = document.getElementById('bookmark');
    const $bmCard = document.getElementById('bmCard');
    const $bmList = document.getElementById('bmList');
    const $copyUrl = document.getElementById('copyUrl');

    const LS_TABS = 'cb_tabs_v1';
    const LS_BM = 'cb_bookmarks_v1';
    const LS_PREFS = 'cb_prefs_v1';
    const defaultPrefs = { restoreSession: true, startOnNewTab: true };

    function loadPrefs(){ try{ return Object.assign({}, defaultPrefs, JSON.parse(localStorage.getItem(LS_PREFS)||'{}')); }catch{ return {...defaultPrefs}; } }
    function savePrefs(p){ try{ localStorage.setItem(LS_PREFS, JSON.stringify(p)); }catch{} }

    let progTimer = null;
    function setProgress(val){ $prog.style.width = Math.max(0, Math.min(100, val)) + '%'; }
    function startProgress(){
      clearInterval(progTimer);
      setProgress(3);
      progTimer = setInterval(()=>{
        const cur = parseFloat($prog.style.width)||0;
        const next = cur + (cur < 30 ? 2 : cur < 70 ? 1 : 0.2);
        setProgress(next);
      }, 120);
    }
    function stopProgress(){ clearInterval(progTimer); setProgress(100); setTimeout(()=> setProgress(0), 250); }

    const tabs = [];
    let activeTabId = null;
    let nextId = 1;
    const closedTabs = [];

    function esc(s){ return String(s==null?'':s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
    function tabById(id){ return tabs.find(t=>t.id===id) || null; }
    function currentTab(){ return tabById(activeTabId); }
    function updateDocumentTitle(){
      const t = currentTab();
      const tt = t && t.title ? t.title : 'CloudPRX';
      document.title = (tt && tt !== 'CloudPRX') ? tt + ' ‚Äì CloudPRX' : 'CloudPRX';
    }
    function proxiedFaviconFromP(pUrl){
      try{
        const u = new URL(pUrl, location.origin);
        const m = u.pathname.match(/^\\/p\\/(https?)\\/([^/]+)\\//i);
        if (!m) return '';
        const sch = m[1], host = m[2];
        return '/p/' + sch + '/' + host + '/favicon.ico';
      }catch{ return ''; }
    }

    // ---------- Bookmarks ----------
    function loadBookmarks(){
      try{ const a = JSON.parse(localStorage.getItem(LS_BM)||'[]'); return Array.isArray(a)?a:[]; }catch{ return []; }
    }
    function saveBookmarks(a){
      try{ localStorage.setItem(LS_BM, JSON.stringify(a.slice(0,200))); }catch{}
    }
    function normalizeUrlForBm(u){
      try{
        const url = new URL(u);
        if (!/^https?:$/i.test(url.protocol)) return '';
        return url.protocol + '//' + url.host + url.pathname + url.search;
      }catch{ return ''; }
    }
    function isBookmarked(u){
      const can = normalizeUrlForBm(u); if (!can) return false;
      return loadBookmarks().some(b=>b.url === can);
    }
    function addBookmark(u, title){
      const can = normalizeUrlForBm(u); if (!can) return;
      const arr = loadBookmarks();
      if (arr.some(b=>b.url===can)) return;
      arr.unshift({ url: can, title: title || can });
      saveBookmarks(arr);
    }
    function removeBookmark(u){
      const can = normalizeUrlForBm(u); if (!can) return;
      const arr = loadBookmarks().filter(b=>b.url !== can);
      saveBookmarks(arr);
    }
    function updateBookmarkStar(){
      const t = currentTab();
      let url = '';
      if (t && t.idx >= 0) url = deproxify(t.hist[t.idx]) || '';
      const on = !!url && isBookmarked(url);
      $bookmark.classList.toggle('active', on);
      $bookmark.title = on ? 'Remove bookmark' : 'Bookmark this page';
    }
    function renderBookmarks(){
      const arr = loadBookmarks();
      if (!arr.length){ $bmCard.hidden = true; $bmList.innerHTML = ''; return; }
      $bmCard.hidden = false;
      $bmList.innerHTML = arr.map(b => {
        const safeT = esc(b.title || b.url);
        const safeU = esc(b.url);
        return \`
          <li>
            <a href="#" data-go="\${safeU}"><span class="tick">‚òÖ</span> \${safeT}</a>
            <button class="rm" data-url="\${safeU}" title="Remove">√ó</button>
          </li>\`;
      }).join('');
    }

    // ---------- Tabs/UI ----------
    function renderTabs(){
      $tabs.innerHTML = "";
      for (const t of tabs){
        const el = document.createElement('button');
        el.className = 'tab' + (t.id===activeTabId ? ' active' : '');
        el.setAttribute('role','tab');
        el.setAttribute('aria-selected', String(t.id===activeTabId));
        el.dataset.id = t.id;
        el.draggable = true;

        const icon = t.loading
          ? '<span class="spinner" aria-hidden="true"></span>'
          : (t.fav ? '<img class="fav" src="'+esc(t.fav)+'" onerror="this.style.display=\\'none\\'" alt="">' : '<span class="fav" aria-hidden="true"></span>');

        el.innerHTML = \`
          \${icon}
          <span class="title">\${esc(t.title || 'New Tab')}</span>
          <span class="close" title="Close" aria-label="Close">√ó</span>
        \`;
        $tabs.appendChild(el);
      }
      const add = document.createElement('button');
      add.className = 'tab add'; add.id = 'addTab';
      add.title = 'New Tab (Ctrl+T)'; add.setAttribute('aria-label','New Tab');
      add.textContent = '+';
      $tabs.appendChild(add);

      const actEl = $tabs.querySelector('.tab[aria-selected="true"]');
      if (actEl) {
        const r = actEl.getBoundingClientRect(), p = $tabs.getBoundingClientRect();
        if (r.left < p.left) $tabs.scrollLeft -= (p.left - r.left) + 16;
        if (r.right > p.right) $tabs.scrollLeft += (r.right - p.right) + 16;
      }

      updateDocumentTitle();
    }

    function onHomeView(){ return !$v.classList.contains('show'); }

    function showPage(show){
      const t = currentTab();
      if (show){
        $v.classList.add('show');
        $hero.style.display = 'none';
      } else {
        $v.classList.remove('show');
        $hero.style.display = 'grid';
        if ($u) $u.value = '';
        if (t){ t.loading = false; t.fav = ''; renderTabs(); saveSession(); }
        renderBookmarks();
      }
    }

    function updateSecurityIcon(){
      const t = currentTab();
      let url = '';
      if (t && t.idx >= 0) url = deproxify(t.hist[t.idx]) || '';
      const isHttps = /^https:\\/\\//i.test(url);
      $lock.title = isHttps ? 'Connection is secure (HTTPS)' : 'Connection is not fully secure (HTTP)';
    }

    function updateNavButtons(){
      const t = currentTab();
      const hasHist = !!(t && t.hist && t.hist.length);
      $back.disabled = !(t && t.idx > 0);
      $fwd.disabled = !(t && t.hist && t.idx < t.hist.length - 1);
      $refresh.disabled = !hasHist;
      $home.disabled = false;

      if (onHomeView()) { $u.value = ''; }
      else if (t){
        if (t.idx >= 0) $u.value = deproxify(t.hist[t.idx]) || '';
        else $u.value = '';
      } else { $u.value = ''; }

      updateSecurityIcon();
      updateBookmarkStar();
    }

    function saveSession(){
      try{
        const data = {
          active: activeTabId,
          tabs: tabs.map(t=>({ id:t.id, title:t.title, fav:t.fav||'', hist:t.hist.slice(0,100), idx: t.idx }))
        };
        localStorage.setItem(LS_TABS, JSON.stringify(data));
      }catch{}
    }

    function newTab(initialUrl = ''){
      const id = 't' + (nextId++);
      const t = { id, title: 'New Tab', hist: [], idx: -1, fav:'', loading:false };
      tabs.push(t);
      switchTab(id, false);
      renderTabs();
      saveSession();
      if (initialUrl) navigateTo(initialUrl);
      return id;
    }

    function pushClosed(t){
      try{
        closedTabs.push({ title:t.title, fav:t.fav, hist:t.hist.slice(), idx:t.idx });
        if (closedTabs.length > 20) closedTabs.shift();
      }catch{}
    }
    function reopenClosed(){
      const last = closedTabs.pop(); if (!last) return;
      const id = newTab();
      const t = tabById(id);
      t.title = last.title || 'New Tab';
      t.fav = last.fav || '';
      t.hist = Array.isArray(last.hist) ? last.hist : [];
      t.idx = (typeof last.idx==='number'? last.idx : (t.hist.length? t.hist.length-1 : -1));
      if (t.idx < 0) t.fav = '';
      renderTabs();
      switchTab(id, false);
      if (t.idx >= 0){ $v.dataset.tabId = t.id; $v.src = t.hist[t.idx]; showPage(true); }
      else { showPage(false); }
      saveSession();
    }

    function closeTab(id){
      const i = tabs.findIndex(t=>t.id===id);
      if (i === -1) return;
      const wasActive = (activeTabId === id);
      pushClosed(tabs[i]);
      tabs.splice(i,1);
      if (!tabs.length){
        activeTabId = null;
        renderTabs();
        $v.src = 'about:blank';
        showPage(false);
        updateNavButtons();
        newTab();
        saveSession();
        return;
      }
      if (wasActive){
        const nextIdx = Math.max(0, i-1);
        switchTab(tabs[nextIdx].id, false);
      }
      renderTabs();
      saveSession();
    }

    function switchTab(id, focusUrlInput = false){
      const t = tabById(id);
      if (!t) return;
      activeTabId = id;

      if (t.idx < 0) t.fav = '';

      renderTabs();

      if (t.idx >= 0){
        $v.dataset.tabId = id;
        $v.src = t.hist[t.idx];
        showPage(true);
      } else {
        $v.dataset.tabId = id;
        $v.src = 'about:blank';
        showPage(false);
      }
      if (focusUrlInput) $u.focus();
      updateNavButtons();
      updateDocumentTitle();
      saveSession();
    }

    const BRAVE = (q) => 'https://search.brave.com/search?q=' + encodeURIComponent(q);

    function isProbablyURL(s){
      if (/^https?:\\/\\//i.test(s)) return true;
      if (/\\s/.test(s)) return false;
      if (/^localhost(:\\d+)?(\\/|$)/i.test(s)) return true;
      if (/^\\d{1,3}(\\.\\d{1,3}){3}(:\\d+)?(\\/|$)/.test(s)) return true;
      if (s.includes('.')) return true;
      return false;
    }

    function normalize(input){
      let s = (input || '').trim();
      if (!s) return '';
      if (isProbablyURL(s)) {
        if (!/^https?:\\/\\//i.test(s)) s = 'https://' + s;
        try { new URL(s); } catch { return BRAVE(input); }
        return s;
      }
      return BRAVE(s);
    }

    function toProxyPath(u){
      const url = new URL(u);
      const scheme = url.protocol.replace(':','');
      const hp = url.host;
      const path = url.pathname.replace(/^\\/+/, '');
      return '/p/' + scheme + '/' + hp + '/' + path + url.search;
    }

    function deproxify(pUrl){
      try {
        const u = new URL(pUrl, location.origin);
        const m = u.pathname.match(/^\\/p\\/(https?)\\/([^/]+)\\/(.*)$/i);
        if (!m) return '';
        const sch = m[1]; const hp = m[2]; const rest = m[3] || '';
        return sch + '://' + hp + '/' + rest + (u.search || '');
      } catch { return ''; }
    }

    function pushHist(t, pUrl){
      if (!t) return;
      if (t.idx >= 0 && t.hist[t.idx] === pUrl) return;
      t.hist.splice(t.idx + 1);
      t.hist.push(pUrl);
      t.idx = t.hist.length - 1;
      updateNavButtons();
      saveSession();
    }

    function navigateTo(raw){
      const t = currentTab(); if (!t) return;
      const urlOrSearch = normalize(raw);
      if (!urlOrSearch) return;
      const p = toProxyPath(urlOrSearch);
      t.loading = true;
      t.fav = proxiedFaviconFromP(p) || '';
      pushHist(t, p);
      startProgress();
      $v.dataset.tabId = t.id;
      $v.src = p;
      showPage(true);
      renderTabs();
    }

    document.getElementById('go').addEventListener('submit', (e) => {
      e.preventDefault();
      navigateTo($u.value);
    });

    function toggleMenu(show, anchor){
      if (!show){ $menu.classList.remove('show'); $menu.setAttribute('aria-hidden','true'); return; }
      const rect = anchor.getBoundingClientRect();
      $menu.style.left = (rect.right - 220) + 'px';
      $menu.style.top = (rect.bottom + 8) + 'px';
      $menu.classList.add('show');
      $menu.setAttribute('aria-hidden','false');
    }
    $more.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleMenu(!$menu.classList.contains('show'), $more);
    });
    document.addEventListener('click', (e) => {
      if (!$menu.contains(e.target) && e.target !== $more) toggleMenu(false);
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') toggleMenu(false); });
    $menu.addEventListener('click', (e)=>{
      const it = e.target.closest('.item'); if (!it) return;
      const act = it.dataset.act;
      toggleMenu(false);
      if (act === 'new'){ newTab(); renderTabs(); updateNavButtons(); }
      if (act === 'reopen'){ reopenClosed(); }
      if (act === 'help'){ openHelp(); }
      if (act === 'about'){ alert('CloudPRX ‚Äî Discord-like proxy UI using Brave search.'); }
      if (act === 'bm'){ $home.click(); setTimeout(()=>{ if ($bmCard) $bmCard.scrollIntoView({behavior:'smooth', block:'center'}); }, 60); }
      if (act === 'prefs'){ showPrefs(); }
      if (act === 'panic'){ panic(); }
    });

    $copyUrl.addEventListener('click', async () => {
      const t = currentTab(); if (!t || t.idx < 0) return;
      const url = deproxify(t.hist[t.idx]) || '';
      if (!url) return;
      try { await navigator.clipboard.writeText(url); } catch {}
    });

    $bookmark.addEventListener('click', () => {
      const t = currentTab(); if (!t || t.idx < 0) return;
      const url = deproxify(t.hist[t.idx]) || '';
      if (!url) return;
      if (isBookmarked(url)) removeBookmark(url);
      else addBookmark(url, t.title || url);
      updateBookmarkStar();
      renderBookmarks();
    });
    $lock.addEventListener('click', () => openHelp());

    $heroSearch.addEventListener('submit', (e) => {
      e.preventDefault();
      const q = ($q.value || '').trim();
      if (!q) return;
      navigateTo(BRAVE(q));
    });

    $workList.addEventListener('click', (e) => {
      const a = e.target.closest('[data-go]');
      if (!a) return;
      e.preventDefault();
      const u = a.getAttribute('data-go') || '';
      if (u) navigateTo(u);
    });

    $bmList.addEventListener('click', (e) => {
      const rm = e.target.closest('.rm');
      if (rm){
        const u = rm.getAttribute('data-url')||'';
        if (u){ removeBookmark(u); renderBookmarks(); updateBookmarkStar(); }
        return;
      }
      const a = e.target.closest('[data-go]');
      if (!a) return;
      e.preventDefault();
      const u = a.getAttribute('data-go') || '';
      if (u) navigateTo(u);
    });

    $workList.addEventListener('auxclick', (e) => {
      if (e.button !== 1) return;
      const a = e.target.closest('[data-go]');
      if (!a) return;
      e.preventDefault();
      const u = a.getAttribute('data-go') || '';
      if (!u) return;
      const id = newTab();
      switchTab(id);
      navigateTo(u);
    });

    $v.addEventListener('load', () => {
      stopProgress();
      const t = currentTab();
      try {
        if ($v.src.endsWith('about:blank')) {
          if (t){ t.loading = false; t.fav = ''; renderTabs(); saveSession(); }
          showPage(false);
          updateNavButtons();
          updateDocumentTitle();
          return;
        }
        const u = new URL($v.src, location.origin);
        const cur = u.pathname + u.search;
        if (t && (t.idx < 0 || t.hist[t.idx] !== cur)) pushHist(t, cur);
        if (t){
          t.loading = false;
          try {
            const titleCandidate = ($v.contentDocument && $v.contentDocument.title) ? $v.contentDocument.title : '';
            t.title = titleCandidate || (new URL(deproxify($v.src))).host || 'Tab';
          } catch {
            t.title = (new URL(deproxify($v.src))).host || 'Tab';
          }
          t.fav = proxiedFaviconFromP(cur) || '';
          renderTabs();
          updateNavButtons();
          updateDocumentTitle();
          saveSession();
        }
        showPage(true);
      } catch { showPage(true); }
    });

    // UPDATED: message handler now understands {type:"home"} from error pages
    window.addEventListener('message', (e) => {
      const d = e.data;
      if (!d || !d.__cb) return;
      if (d.type === 'home'){ // trigger real Home (no nesting)
        $home.click();
        return;
      }
      if (d.type !== 'loc') return;
      const t = currentTab();
      if ($v.contentWindow !== e.source) return;
      try {
        const href = String(d.href || '');
        if (!href) return;
        const u = new URL(href, location.origin);
        const cur = u.pathname + u.search;
        if (t && (t.idx < 0 || t.hist[t.idx] !== cur)) pushHist(t, cur);
        if (t){
          t.title = d.title || (new URL(deproxify(cur), location.origin)).host || 'Tab';
          t.fav = proxiedFaviconFromP(cur) || '';
          t.loading = false;
          renderTabs();
          updateNavButtons();
          updateDocumentTitle();
          saveSession();
        }
      } catch {}
    });

    $home.addEventListener('click', () => {
      stopProgress();
      const t = currentTab();
      if (t){
        t.title = 'New Tab';
        t.loading = false;
        t.fav = '';
      }
      $v.src = 'about:blank';
      showPage(false);
      updateNavButtons();
      updateDocumentTitle();
      renderTabs();
      saveSession();
    });

    $back.addEventListener('click', () => {
      const t = currentTab(); if (!t || t.idx <= 0) return;
      t.idx -= 1;
      startProgress(); t.loading=true; renderTabs();
      $v.dataset.tabId = t.id;
      $v.src = t.hist[t.idx];
      updateNavButtons();
      showPage(true);
      saveSession();
    });

    $fwd.addEventListener('click', () => {
      const t = currentTab(); if (!t || t.idx >= t.hist.length - 1) return;
      t.idx += 1;
      startProgress(); t.loading=true; renderTabs();
      $v.dataset.tabId = t.id;
      $v.src = t.hist[t.idx];
      updateNavButtons();
      showPage(true);
      saveSession();
    });

    $refresh.addEventListener('click', () => {
      const t = currentTab(); if (!t || t.idx < 0) return;
      const u = new URL(t.hist[t.idx], location.origin);
      u.searchParams.set('_cb', Date.now().toString(36));
      t.hist[t.idx] = u.pathname + u.search;
      startProgress(); t.loading=true; renderTabs();
      $v.dataset.tabId = t.id;
      $v.src = t.hist[t.idx];
      saveSession();
    });

    $tabs.addEventListener('click', (e) => {
      const closeBtn = e.target.closest('.close');
      const tabBtn = e.target.closest('.tab');
      if (!tabBtn) return;
      if (tabBtn.id === 'addTab'){ newTab(); renderTabs(); updateNavButtons(); return; }
      const id = tabBtn.dataset.id;
      if (!id) return;
      if (closeBtn){ closeTab(id); return; }
      switchTab(id);
    });
    $tabs.addEventListener('auxclick', (e) => {
      if (e.button !== 1) return;
      const tabBtn = e.target.closest('.tab');
      if (!tabBtn || tabBtn.id === 'addTab') return;
      e.preventDefault();
      const id = tabBtn.dataset.id; if (id) closeTab(id);
    });

    let dragId = null;
    $tabs.addEventListener('dragstart', (e) => {
      const t = e.target.closest('.tab'); if (!t || t.id==='addTab') { e.preventDefault(); return; }
      dragId = t.dataset.id;
      t.classList.add('dragging');
      e.dataTransfer.setData('text/plain', dragId);
      e.dataTransfer.effectAllowed = 'move';
    });
    $tabs.addEventListener('dragend', (e) => {
      const t = e.target.closest('.tab'); if (t) t.classList.remove('dragging');
      dragId = null; saveSession();
    });
    $tabs.addEventListener('dragover', (e) => {
      e.preventDefault();
      const over = e.target.closest('.tab'); if (!over || over.id==='addTab') return;
      const overId = over.dataset.id;
      if (!dragId || dragId===overId) return;
      const from = tabs.findIndex(t=>t.id===dragId);
      const to = tabs.findIndex(t=>t.id===overId);
      if (from === -1 || to === -1) return;
      const rect = over.getBoundingClientRect();
      const placeAfter = e.clientX > (rect.left + rect.width/2);
      const newIndex = to + (placeAfter?1:0);
      const item = tabs.splice(from,1)[0];
      tabs.splice(newIndex <= from ? newIndex : newIndex-1, 0, item);
      renderTabs();
    });

    function openHelp(){
      $helpModal.classList.add('show');
      $helpModal.setAttribute('aria-hidden','false');
      const btn = $helpModal.querySelector('.closeX'); if (btn) btn.focus();
      document.addEventListener('keydown', onHelpKeydown, true);
      $helpModal.addEventListener('click', onHelpBackdrop, true);
    }
    function closeHelp(){
      $helpModal.classList.remove('show');
      $helpModal.setAttribute('aria-hidden','true');
      document.removeEventListener('keydown', onHelpKeydown, true);
      $helpModal.removeEventListener('click', onHelpBackdrop, true);
    }
    function onHelpKeydown(e){ if (e.key === 'Escape') { e.preventDefault(); closeHelp(); } }
    function onHelpBackdrop(e){ if (e.target.classList.contains('backdrop')) closeHelp(); }
    $helpModal.querySelector('.closeX').addEventListener('click', closeHelp);

    function openChromeNewTab(){
      try { const w = window.open('chrome://newtab','_blank'); if (!w) throw 0; } catch { try { window.open('about:blank','_blank'); } catch {} }
    }
    function panic(){
      try { localStorage.clear(); sessionStorage.clear(); } catch {}
      openChromeNewTab();
      try { location.replace('about:blank'); } catch { location.href = 'about:blank'; }
    }

    function showPrefs(){
      const prefs = loadPrefs();
      const restore = confirm(\`Restore previous session on startup?\\n\\nCurrently: \${prefs.restoreSession ? 'ON' : 'OFF'}\`);
      prefs.restoreSession = restore;
      const startOnNtp = confirm(\`Start on New Tab even when restoring session?\\n\\nCurrently: \${prefs.startOnNewTab ? 'ON' : 'OFF'}\`);
      prefs.startOnNewTab = startOnNtp;
      savePrefs(prefs);
    }

    window.addEventListener('keydown', (e) => {
      if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 't'){ e.preventDefault(); newTab(); renderTabs(); updateNavButtons(); return; }
      if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'w'){ e.preventDefault(); const t = currentTab(); if (t) closeTab(t.id); return; }
      if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 't'){ e.preventDefault(); reopenClosed(); return; }
      if (e.ctrlKey && e.key === 'Tab'){ e.preventDefault();
        if (!tabs.length) return;
        const dir = e.shiftKey ? -1 : 1;
        const curIndex = Math.max(0, tabs.findIndex(t=>t.id===activeTabId));
        const next = (curIndex + dir + tabs.length) % tabs.length;
        switchTab(tabs[next].id);
        return;
      }
      if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'l'){ e.preventDefault(); $u.focus(); $u.select(); return; }
      if (e.ctrlKey && !e.shiftKey && (e.key.toLowerCase() === 'r')){ e.preventDefault(); $refresh.click(); return; }
      if (e.altKey && e.key === 'ArrowLeft'){ e.preventDefault(); $back.click(); return; }
      if (e.altKey && e.key === 'ArrowRight'){ e.preventDefault(); $fwd.click(); return; }
      if (e.ctrlKey && /^[1-9]$/.test(e.key)){ e.preventDefault(); const n = parseInt(e.key,10)-1; if (n < tabs.length) switchTab(tabs[n].id); return; }
      if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'p'){ e.preventDefault(); panic(); return; }
      if (e.key === 'F1'){ e.preventDefault(); openHelp(); return; }
    });

    (function startup(){
      const prefs = loadPrefs();
      const raw = localStorage.getItem(LS_TABS);
      if (prefs.restoreSession && raw){
        try{
          const saved = JSON.parse(raw);
          if (saved && saved.tabs && saved.tabs.length){
            for (const st of saved.tabs){
              const id = newTab();
              const t = tabById(id);
              t.title = st.title || 'New Tab';
              t.fav = st.fav || '';
              t.hist = Array.isArray(st.hist) ? st.hist : [];
              t.idx = typeof st.idx === 'number' ? st.idx : (t.hist.length ? t.hist.length-1 : -1);
            }
            switchTab(saved.active || tabs[0].id, false);
            if (prefs.startOnNewTab) { $home.click(); }
            renderTabs(); updateNavButtons(); renderBookmarks(); updateBookmarkStar();
            return;
          }
        }catch{}
      }
      const id = newTab();
      switchTab(id);
      showPage(false);
      renderBookmarks();
      updateBookmarkStar();
      const hashU = (location.hash.match(/[#&]u=([^&]+)/) || [])[1];
      if (hashU) { try { navigateTo(decodeURIComponent(hashU)); } catch {} }
      if ($u) $u.value = '';
    })();
  </script>
</body>
</html>`;
}

// ---------- Optional SW ----------

function swJS(){
  return `// scope: /p/
self.addEventListener('install', e=>self.skipWaiting());
self.addEventListener('activate', e=>self.clients.claim());
self.addEventListener('fetch', e=>{ /* no-op */ });
`;
}

// ---------- Minimal error pages (with real Home behavior) ----------

function statusText(code){
  const map = {
    400:"Bad Request",401:"Unauthorized",403:"Forbidden",404:"Not Found",
    405:"Method Not Allowed",408:"Request Timeout",409:"Conflict",
    410:"Gone",413:"Payload Too Large",414:"URI Too Long",415:"Unsupported Media Type",
    418:"I'm a teapot",429:"Too Many Requests",
    500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",
    503:"Service Unavailable",504:"Gateway Timeout",530:"Cloudflare 1016/Origin DNS error"
  };
  return map[code] || `Error ${code}`;
}

function errorHTML({ code=500, label=statusText(500), message="Something went wrong.", detail="" }={}){
  // Minimal, Chrome-ish structure but Discord palette; real Home button behavior via postMessage to parent viewer
  return `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>${escapeHtmlAttr(label)} ‚Äì CloudPRX</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{
    --bg:#ffffff; --ink:#2b2d31; --muted:#6b6f78; --border:#e0e3e7; --btn:#5865F2; --btn-ink:#fff;
  }
  @media (prefers-color-scheme: dark){
    :root{ --bg:#1e1f22; --ink:#e3e5e8; --muted:#b5bac1; --border:#3f4147; --btn:#5865F2; --btn-ink:#111; }
  }
  *{box-sizing:border-box}
  body{ margin:0; background:var(--bg); color:var(--ink); font: 14px/1.55 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
  .wrap{ min-height:100vh; display:grid; place-items:center; padding:24px; }
  .card{ width:min(680px, 100%); border:1px solid var(--border); border-radius:12px; padding:20px; }
  .row{ display:flex; gap:12px; align-items:flex-start; }
  .icon{ width:28px; height:28px; border:1px solid var(--border); border-radius:6px; display:grid; place-items:center; font-weight:700; }
  h1{ margin:0 0 6px; font-size:16px; }
  p{ margin:0 0 10px; color:var(--muted); }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  .actions{ margin-top:12px; display:flex; gap:8px; }
  .btn{ height:32px; padding:0 12px; border-radius:8px; border:1px solid var(--border); background:transparent; color:var(--ink); cursor:pointer; }
  .btn.primary{ background:var(--btn); color:var(--btn-ink); border-color:transparent; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="alert" aria-live="polite">
      <div class="row">
        <div class="icon">!</div>
        <div>
          <h1>${escapeHtmlAttr(label)}</h1>
          <p>${escapeHtmlAttr(message)}</p>
          ${detail ? `<p class="mono">${escapeHtmlAttr(detail)}</p>` : ``}
          <p class="mono">Status: ${String(code)}</p>
          <div class="actions">
            <button id="homeBtn" class="btn primary" type="button">Home</button>
            <button id="reloadBtn" class="btn" type="button">Reload</button>
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
  (function(){
    try{
      var h = document.getElementById('homeBtn');
      var r = document.getElementById('reloadBtn');
      if (h) h.addEventListener('click', function(){
        var msg = {__cb:1, type:'home'};
        try{ parent && parent.postMessage(msg, '*'); }catch(_){}
        try{ top && top !== window && top.postMessage(msg, '*'); }catch(_){}
        try{
          if (window.self !== window.top) { window.top.location.href = '/'; }
          else { location.href = '/'; }
        }catch(_){ location.href = '/'; }
      });
      if (r) r.addEventListener('click', function(){ try{ location.reload(); }catch(_){ location.href = location.href; } });
    }catch(_){}
  })();
</script>
</body>
</html>`;
}

// ---------- Small utils ----------

function escapeHtmlAttr(s){
  return String(s).replace(/["&<>]/g, (c)=>({'"':"&quot;","&":"&amp;","<":"&lt;",">":"&gt;"}[c]));
}
function mergeHeaders(headers, extra){ const out = new Headers(headers); for (const [k,v] of Object.entries(extra)) out.set(k, v); return out; }
function withHeaders(body, hdrs){ return new Response(body, { status: 200, headers: hdrs }); }

// Replaces plain "text()" with minimal HTML for error statuses
function text(msg, status=200){
  if (status >= 400) {
    const html = errorHTML({
      code: status,
      label: statusText(status),
      message: String(msg || statusText(status))
    });
    return new Response(html, {
      status,
      headers: { "content-type":"text/html; charset=UTF-8", "x-content-type-options":"nosniff", "cache-control":"no-store" },
    });
  }
  return new Response(String(msg), {
    status,
    headers: { "content-type":"text/plain; charset=UTF-8", "x-content-type-options":"nosniff" },
  });
}
